<?php

/**
 * @file
 * Contains comp_onsave.module.
 */

use Drupal\node\Entity\Node;
use Drupal\file\Entity\File;

/**
 * Implements hook_entity_presave().
 */
function comp_onsave_entity_presave($entity) {
  // Process for different content types.
  switch($entity->bundle()) {

    // If the entity is a composite...
    case 'composite':
      // Process and add decade value.
      // Retrieve year.
      $year = $entity->get('field_comp_year')->getValue()[0]['value'];
      $decade = intdiv($year, 10) * 10;
      $decade = $decade >= 1870 ? $decade : NULL;
      $entity->set('field_comp_decade', $decade);

      // Sort subjects by last name.
      // Retrieve subject node ids associated to composite.
      $sids = $entity->get('field_subjects')->getValue();

      // Retrieve title (name) for each id.
      foreach ($sids as $k=>$sid) {
        $subject = Node::load($sid['target_id']);
        $sid['name'] = $subject->getTitle();
        $sids[$k] = $sid;
        // Since we have the subject, add a reference back to the composite.
        $comp_ref = ['target_id' => $entity->id()];
        $subject->set('field_composite', $comp_ref);
        $subject->save();
      }

      // Sort multidimensional array by name column.
      array_multisort(array_column($sids, 'name'), SORT_ASC, $sids);

      // Create array with only the new sorted 'target_id'.
      $sorted_sids = [];

      foreach ($sids as $k=>$sid) {
        $sorted_sids[$k] = ['target_id' => $sid['target_id']];
      }

      // Update field value with the sorted ids.
      $entity->get('field_subjects')->setValue($sorted_sids);
    break;

    // If the entity is a subject...
    case 'subject':
      // Build name and save as title.
      // Retrieve name fields.
      $lname = $entity->get('field_last_name')->getValue()[0]['value'];

      if (!empty($entity->get('field_given_name')->getValue()[0]['value'])) {
        $gname = $entity->get('field_given_name')->getValue()[0]['value'];
      }

      $title = empty($gname) ? $lname : $lname . ', ' . $gname;
      $entity->set('title', $title);

      // Process and populate sort initial field.
      // Get first title character and classify.
      $leading = strtoupper(substr($title, 0, 1));

      if (ctype_alnum($leading)) {

        if (ctype_digit($leading)) {
            $leading = '#';
        }
      }
      else {
        $leading = '@';
      }

      $entity->set('field_sort_initial', $leading);
    break;
  }
}

/**
 * Implements hook_entity_insert().
 */
function comp_onsave_entity_insert($entity) {
  // Process for different content types.
  switch($entity->bundle()) {

    // If the entity is a composite...
    case 'composite':
    // Generate DZI file and tiles.
    $fid = $entity->get('field_image')->getValue()[0]['target_id'];
    $nid = $entity->id();

    if (!empty($fid)) {
      prepare_dzi_batch($fid, $nid);
    }
    break;

    // If the entity is a subject...
    case 'subject':
      if (!empty($entity->get('field_composite')->getValue()[0]['target_id'])) {
        $cid = $entity->get('field_composite')->getValue()[0]['target_id'];
      }

      if (!empty($cid)) {
        $composite = Node::load($cid);
        $subjects = $composite->get('field_subjects')->getValue();
        $sid = $entity->id();

        if (!in_array($sid, $subjects)) {
          $subjects[] = [ 'target_id' => $sid ];
          $composite->set('field_subjects', $subjects);
          $composite->save();
        }
      }
    break;
  }
}

/**
 * Implements hook_entity_update().
 */
function comp_onsave_entity_update($entity) {
  // Process for different content types.
  switch($entity->bundle()) {

    // If the entity is a composite...
    case 'composite':
    // Generate DZI file and tiles.
    $fid = $entity->get('field_image')->getValue()[0]['target_id'];
    $nid = $entity->id();

    if (!empty($fid)) {
      prepare_dzi_batch($fid, $nid);
    }
    break;
  }
}

/**
 * Prepare batch process for DZI tile generation.
 */
function prepare_dzi_batch($fid, $nid) {
  // Prepare batch processing.
  $batch = array(
    'title' => t('Updating high-resolution DZI tiles for file ID [' .
      $fid . ']...'),
    'operations' => [],
    'init_message'     => t('Starting...'),
    'progress_message' => t('Processed @current out of @total.'),
    'error_message'    => t('An error occurred during processing.'),
    'finished' => t('Done.'),
  );

  // Add generation of DZI tiles for file to batch operations.
  $batch['operations'][] = ['generate_dzi_tiles', [$fid, $nid]];

  // Add batch.
  batch_set($batch);
}

/**
 * Generates DZI tiles for the given image file.
 */
function generate_dzi_tiles($fid, $nid) {
  $file = File::load($fid);
  $filename = $file->getFilename();
  // Cut extension from filename.
  $fn_plain = substr($filename, 0, -4);
  // Get image path.
  $img_location = \Drupal::service('file_system')->realpath(file_default_scheme() . "://") . "/comp_images";
  $img_path = $img_location . "/$filename";
  $dzi_path = $img_location . "/dzi/composite_$nid";

  $command = "/usr/local/bin/magick-slicer -e jpg -i \"{$img_path}\"" .
   " -o \"{$dzi_path}\"";

  // Run command in shell.
  exec($command, $output, $return);

  // For batch process.
  $context['message'] = t(
    'Generated DZI tiles for high-resolution composite file @file',
    [
     '@file' => $fn_plain,
    ]
  );
}
